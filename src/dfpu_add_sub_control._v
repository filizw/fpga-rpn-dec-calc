`timescale 1ns / 1ps

`include "bcdu_op_codes.vh"
`include "bcdu_flags.vh"

module dfpu_add_sub_control #(
    parameter EXP_WIDTH = 7
)(
    input wire                          i_clk,
    input wire                          i_rst,
    input wire                          i_start,
    input wire                          i_sub,
    input wire                          i_sign_a,
    input wire                          i_sign_b,
    input wire          [EXP_WIDTH-1:0] i_exp_a,
    input wire          [EXP_WIDTH-1:0] i_exp_b,
    input wire                    [3:0] i_bcdu_addr_a,
    input wire                    [3:0] i_bcdu_addr_b,
    input wire                    [3:0] i_bcdu_digit,
    input wire [`BCDU_NUM_FLAGS-1:0] i_bcdu_status,
    input wire                          i_bcdu_ready,
    output wire                         o_sign,
    output wire         [EXP_WIDTH-1:0] o_exp,
    output wire                         o_bcdu_valid,
    output reg                   [15:0] o_bcdu_instr,
    output reg                          o_done
);
    
    localparam [2:0] STATE_COMPARE    = 3'd0;
    localparam [2:0] STATE_ALIGN      = 3'd1;
    localparam [2:0] STATE_WAIT       = 3'd2;
    localparam [2:0] STATE_ADD_OR_SUB = 3'd3;
    localparam [2:0] STATE_CLEAR      = 3'd4;
    localparam [2:0] STATE_CORRECT    = 3'd5;

    reg [2:0] state_reg, state_next;
    reg       bcdu_gf_reg, bcdu_gf_next;

    initial begin
        state_reg   = 3'b0;
        bcdu_gf_reg = 1'b0;
    end

    wire exp_a_gt_b = (i_exp_a > i_exp_b);
    wire subtract   = (i_sub & ~(i_sign_a ^ i_sign_b) | ~i_sub & (i_sign_a ^ i_sign_b));
    wire correct    = (~bcdu_gf_reg & subtract);

    assign o_sign = (bcdu_gf_reg & i_sign_a | ~bcdu_gf_reg & (i_sub ^ i_sign_b));
    assign o_exp  = (exp_a_gt_b ? i_exp_b : i_exp_a);

    assign o_bcdu_valid = 1'b1;

    always @* begin
        o_bcdu_instr = {`BCDU_OP_NOP, 12'b0};
        o_done       = 1'b0;

        state_next   = state_reg;
        bcdu_gf_next = bcdu_gf_reg;

        if (i_bcdu_ready) begin
            case (state_reg)
                STATE_COMPARE: begin
                    if (i_start) begin
                        o_bcdu_instr = {`BCDU_OP_CMP, i_bcdu_addr_a, i_bcdu_addr_b, 4'b0};
                        state_next   = STATE_ALIGN;
                    end

                    bcdu_gf_next = 1'b0;
                    o_done       = 1'b1;
                end

                STATE_ALIGN: begin
                    if (exp_a_gt_b) o_bcdu_instr = {`BCDU_OP_SHL, i_bcdu_addr_a, {8-EXP_WIDTH{1'b0}}, i_exp_a - i_exp_b};
                    else            o_bcdu_instr = {`BCDU_OP_SHL, i_bcdu_addr_b, {8-EXP_WIDTH{1'b0}}, i_exp_b - i_exp_a};

                    state_next = STATE_WAIT;
                end

                STATE_WAIT: begin
                    state_next = STATE_ADD_OR_SUB;
                end

                STATE_ADD_OR_SUB: begin
                    o_bcdu_instr = {(subtract ? `BCDU_OP_SUB : `BCDU_OP_ADD), i_bcdu_addr_a, i_bcdu_addr_a, i_bcdu_addr_b};
                    state_next   = STATE_CLEAR;
                    bcdu_gf_next = i_bcdu_status[`BCDU_GF];
                end

                STATE_CLEAR: begin
                    o_bcdu_instr = {`BCDU_OP_CLR, i_bcdu_addr_b, 8'b0};
                    state_next   = (correct ? STATE_CORRECT : STATE_COMPARE);
                end

                STATE_CORRECT: begin
                    o_bcdu_instr = {`BCDU_OP_SUB, i_bcdu_addr_a, i_bcdu_addr_b, i_bcdu_addr_a};
                    state_next   = STATE_COMPARE;
                end
            endcase
        end
    end

    always @(posedge i_clk) begin
        if (i_rst) begin
            state_reg   <= 3'b0;
            bcdu_gf_reg <= 1'b0;
        end else begin
            state_reg   <= state_next;
            bcdu_gf_reg <= bcdu_gf_next;
        end
    end

endmodule
