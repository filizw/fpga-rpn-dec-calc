`timescale 1ns / 1ps

`include "du_symbols.vh"
`include "bcdu_op_codes.vh"
`include "bcdu_flags.vh"

module dfpu_executor #(
    parameter NUM_DIGITS  = 4,
    parameter STACK_DEPTH = 7
)(
    input wire                            i_clk,
    input wire                            i_rst,
    input wire                            i_valid,
    input wire      [`DU_SYM_WIDTH-1:0] i_symbol,
    input wire [`DU_SYM_TYPE_WIDTH-1:0] i_symbol_type,
    input wire                      [3:0] i_bcdu_digit,
    input wire   [`BCDU_NUM_FLAGS-1:0] i_bcdu_status,
    input wire                            i_bcdu_ready,
    output wire                           o_bcdu_valid,
    output wire                    [15:0] o_bcdu_instr,
    output wire     [`DU_SYM_WIDTH-1:0] o_symbol,
    output wire                           o_symbol_valid,
    output wire                           o_ready
);

    localparam COMMA_WIDTH = $clog2(NUM_DIGITS + 1);
    localparam ADDR_WIDTH  = $clog2(STACK_DEPTH);

    reg  [ADDR_WIDTH-1:0] stack_ptr_curr_reg, stack_ptr_curr_next;
    wire [ADDR_WIDTH-1:0] stack_ptr_curr = stack_ptr_curr_reg;
    wire [ADDR_WIDTH-1:0] stack_ptr_prev = (stack_ptr_curr == 0) ? 0 : (stack_ptr_curr - 1);

    wire [3:0] addr_curr = {{4-ADDR_WIDTH{1'b0}}, stack_ptr_curr[ADDR_WIDTH-1:0]};
    wire [3:0] addr_prev = {{4-ADDR_WIDTH{1'b0}}, stack_ptr_prev[ADDR_WIDTH-1:0]};

    reg wr_en;
    reg wr_prev;

    reg  comma_set_reg, comma_set_next;
    wire comma_set = comma_set_reg;

    reg  wr_sign;
    wire rd_sign_prev;
    wire rd_sign_curr;

    reg  [COMMA_WIDTH-1:0] wr_comma;
    wire [COMMA_WIDTH-1:0] rd_comma_prev;
    wire [COMMA_WIDTH-1:0] rd_comma_curr;

    reg_file #(
        .REG_WIDTH(COMMA_WIDTH + 1),
        .NUM_REGS(STACK_DEPTH),
        .ADDR_WIDTH(ADDR_WIDTH)
    ) reg_file_inst (
        .i_clk(i_clk),
        .i_wr_en(wr_en),
        .i_wr_addr(wr_prev ? stack_ptr_prev : stack_ptr_curr),
        .i_wr_data({wr_sign, wr_comma}),
        .i_rd_addr_a(stack_ptr_prev),
        .o_rd_data_a({rd_sign_prev, rd_comma_prev}),
        .i_rd_addr_b(stack_ptr_curr),
        .o_rd_data_b({rd_sign_curr, rd_comma_curr})
    );

    localparam [2:0] STATE_GET_SYMBOL    = 3'd0,
                     STATE_OUTPUT_RESULT = 3'd5;

    reg  [2:0] state_reg, state_next;
    wire [2:0] state = state_reg;

    reg [15:0] bcdu_instr_reg, bcdu_instr_next;
    reg        bcdu_valid_reg, bcdu_valid_next;
    reg        ready_reg, ready_next;

    assign o_bcdu_instr = bcdu_instr_reg;
    assign o_bcdu_valid = bcdu_valid_reg;
    assign o_ready      = ready_reg;

    localparam DIGIT_CNT_WIDTH = $clog2(NUM_DIGITS);

    reg  [DIGIT_CNT_WIDTH-1:0] digit_cnt_reg, digit_cnt_next;
    wire [DIGIT_CNT_WIDTH-1:0] digit_cnt = digit_cnt_reg;

    reg  out_start_reg, out_start_next;
    wire out_done;

    wire [15:0] out_instr;
    wire        out_instr_valid;

    reg loopback_valid;

    du_output_formatter #(
        .NUM_DIGITS(NUM_DIGITS),
        .COMMA_WIDTH(COMMA_WIDTH)
    ) out_ctrl_inst (
        .i_clk(i_clk),
        .i_rst(i_rst),
        .i_loopback_en(loopback_valid),
        .i_symbol(i_symbol),
        .i_stream_start(out_start_reg),
        .i_sign(rd_sign_curr),
        .i_comma(rd_comma_curr),
        .i_bcdu_addr(addr_curr),
        .i_bcdu_digit(i_bcdu_digit),
        .i_bcdu_flags(i_bcdu_status),
        .o_bcdu_instr(out_instr),
        .o_bcdu_instr_valid(out_instr_valid),
        .o_symbol(o_symbol),
        .o_symbol_valid(o_symbol_valid),
        .o_stream_done(out_done)
    );

    always @* begin
        stack_ptr_curr_next = stack_ptr_curr_reg;
        comma_set_next      = comma_set_reg;
        state_next          = state_reg;
        digit_cnt_next      = digit_cnt;
        out_start_next      = 1'b0;

        bcdu_instr_next = {`BCDU_OP_NOP, 12'b0};
        bcdu_valid_next = 1'b0;
        ready_next      = 1'b0;

        wr_en    = 1'b0;
        wr_prev  = 1'b0;
        wr_sign  = 1'b0;
        wr_comma = {COMMA_WIDTH{1'b0}};

        loopback_valid = 1'b0;

        case (state)
            STATE_GET_SYMBOL: begin
                ready_next = 1'b1;

                if (i_valid) begin
                    if (i_symbol_type == `DU_SYM_TYPE_DIGIT) begin
                        bcdu_instr_next = {`BCDU_OP_SHL, addr_curr, 4'b1100, i_symbol[3:0]};
                        bcdu_valid_next = 1'b1;
                        loopback_valid = 1'b1;

                        if (comma_set) begin
                            wr_en    = 1'b1;
                            wr_sign  = rd_sign_curr;
                            wr_comma = rd_comma_curr + {{COMMA_WIDTH-1{1'b0}}, 1'b1};
                        end
                    end else if (i_symbol_type == `DU_SYM_TYPE_SIGN) begin
                        wr_en    = 1'b1;
                        wr_sign  = (i_symbol == `DU_SYM_MINUS) ? 1'b1 : 1'b0;
                        wr_comma = rd_comma_curr;

                        loopback_valid = 1'b1;
                    end else if (i_symbol_type == `DU_SYM_TYPE_COMMA) begin
                        comma_set_next = 1'b1;

                        loopback_valid = 1'b1;
                    end else if (i_symbol_type == `DU_SYM_TYPE_SPECIAL) begin
                        if (i_symbol == `DU_SYM_SEPARATOR) begin
                        end else if (i_symbol == `DU_SYM_RESULT) begin
                            state_next     = STATE_OUTPUT_RESULT;
                            out_start_next = 1'b1;
                        end
                    end
                end
            end

            STATE_OUTPUT_RESULT: begin
                bcdu_instr_next = out_instr;
                bcdu_valid_next = out_instr_valid;

                if (out_done) state_next = STATE_GET_SYMBOL;
            end
        endcase
    end

    always @(posedge i_clk) begin
        if (i_rst) begin
            stack_ptr_curr_reg <= {ADDR_WIDTH{1'b0}};
            comma_set_reg      <= 1'b0;
            state_reg          <= STATE_GET_SYMBOL;
            digit_cnt_reg      <= {DIGIT_CNT_WIDTH{1'b0}};
            out_start_reg      <= 1'b0;

            bcdu_instr_reg <= 16'b0;
            bcdu_valid_reg <= 1'b0;
            ready_reg      <= 1'b0;
        end else begin
            stack_ptr_curr_reg <= stack_ptr_curr_next;
            comma_set_reg      <= comma_set_next;
            state_reg          <= state_next;
            digit_cnt_reg      <= digit_cnt_next;
            out_start_reg      <= out_start_next;

            bcdu_instr_reg <= bcdu_instr_next;
            bcdu_valid_reg <= bcdu_valid_next;
            ready_reg      <= ready_next;
        end
    end

endmodule
